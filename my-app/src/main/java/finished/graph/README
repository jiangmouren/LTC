Graph Theory is one the few important fundamentals.
It is the foundation for many algorithms.
1. Graph types:
   Directed&Undirected

2. Graph representation:
   Adjacency List and Adjacency Matrix. In general we will prefer Adjacency List, because it is easier to use and also
   more compact. If you think about a n-n Adjacency Matrix, all the rows/columns can be viewed as a adjacency list,
   but with unnecessary zeros in it. So normal Adjacency List is more compact.
   This often lead to the thought that why in the case of LinkedList and Tree, we only used one vertex to represent
   the whole graph? That's is because in those cases, the graph is connected and all the connected nodes and edges
   are of interest.
   But in general, the graph is not necessarily all connected and not all connected vertices are included in a graph.
   Refer to "GameOfLife" for more detail.

3. Graph traversal:
   Directed&Undirected + DFS&BFS.

4. Connectivity & Cycle Detection:
   Can use either DFS or BFS. Check if current vertex visited(undirected)/on the current path(directed), to check cycle.
   By the end of the traversal, need to check all nodes are visited, to check the connectivity.

5. Shortest Path:
   BFS&2-directional BFS.

Refer to "DirectedGraph" and "UndirectedGraph" for details.

How "Searching" is different from "Backtracking"?
When using DFS to do Searching, it is really similar to a Backtracking. 
But they are still different in the sense that Searching is trying go find a node, while backtracking is trying to find a path.
Because in "Searching" case, we only care about the node, so what we do is:
1. at every step, we simply looking through all children nodes without condition check;
2. the DFS helper function will directly return the info of interest, that's to say a boolean type in case of exist or not, or a node type in case of returning the node.
But in "Backtracking" case, because we care about the whole path, so what do is:
1. at every step, we will only DFS forward to children nodes, where certain conditions met. We need to check conditions at every point, because the whole path matters;
2. the DFS helper function will have a boolean type in case of exit or not, or a void type in case of finding one/all valid paths. 
